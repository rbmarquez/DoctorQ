# src/models/user.py

import uuid
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, EmailStr, Field, field_validator
from sqlalchemy import CHAR, Column, DateTime, String, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import text

from src.models.base import Base


class PapelUsuario(str, Enum):
    """Enum para papeis de usuario"""

    ADMIN = "admin"
    USUARIO = "usuario"
    ANALISTA = "analista"


def _parse_role(value: Any, *, allow_none: bool) -> Optional[PapelUsuario]:
    """Normaliza valores enviados para o papel do usuario."""

    if value is None or (isinstance(value, str) and not value.strip()):
        return None if allow_none else PapelUsuario.USUARIO

    if isinstance(value, PapelUsuario):
        return value

    if isinstance(value, str):
        try:
            return PapelUsuario(value.strip().lower())
        except ValueError as exc:
            raise ValueError("nm_papel invalido") from exc

    raise ValueError("nm_papel invalido")


class User(Base):
    """Modelo para a tabela tb_users"""

    __tablename__ = "tb_users"

    id_user = Column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        name="id_user",
    )
    nm_microsoft_id = Column(
        String(255), nullable=True, unique=True, name="nm_microsoft_id"
    )
    nm_email = Column(String(255), nullable=False, unique=True, name="nm_email")
    nm_completo = Column(String(255), nullable=False, name="nm_completo")
    nm_papel = Column(
        String(20), nullable=False, server_default=text("'usuario'"), name="nm_papel"
    )
    st_ativo = Column(
        CHAR(1), nullable=False, server_default=text("'S'"), name="st_ativo"
    )
    nm_password_hash = Column(
        String(255), nullable=True, name="nm_password_hash"
    )
    dt_ultimo_login = Column(DateTime, nullable=True, name="dt_ultimo_login")
    nr_total_logins = Column(
        String(10), nullable=False, server_default=text("'0'"), name="nr_total_logins"
    )
    dt_criacao = Column(
        DateTime,
        nullable=False,
        default=func.now(),
        server_default=func.now(),
        name="dt_criacao",
    )
    dt_atualizacao = Column(
        DateTime,
        nullable=False,
        default=func.now(),
        server_default=func.now(),
        onupdate=func.now(),
        name="dt_atualizacao",
    )

    def __repr__(self) -> str:
        return (
            f"<User(id_user={self.id_user}, nm_email='{self.nm_email}', "
            f"nm_papel='{self.nm_papel}')>"
        )


# Pydantic Models para API
class UserBase(BaseModel):
    """Schema base para User"""

    nm_email: EmailStr = Field(..., description="Email do usuario")
    nm_completo: str = Field(..., description="Nome completo")
    nm_papel: Optional[PapelUsuario] = Field(
        PapelUsuario.USUARIO, description="Papel do usuario"
    )
    st_ativo: Optional[Literal["S", "N"]] = Field(
        "S", description="Status ativo: 'S' ou 'N'"
    )

    @field_validator("nm_papel", mode="before")
    @classmethod
    def normalize_role(cls, value: Any) -> PapelUsuario:
        role = _parse_role(value, allow_none=False)
        assert role is not None
        return role


class UserCreate(UserBase):
    """Schema para criar um User"""

    nm_email: EmailStr = Field(..., description="Email do usuario")
    nm_completo: str = Field(..., description="Nome completo")


class UserUpdate(BaseModel):
    """Schema para atualizar um User"""

    id_user: uuid.UUID = Field(..., description="ID unico do usuario")
    nm_completo: Optional[str] = Field(None, description="Nome completo")
    nm_papel: Optional[PapelUsuario] = Field(None, description="Papel do usuario")
    st_ativo: Optional[Literal["S", "N"]] = Field(None, description="Status ativo")

    @field_validator("nm_papel", mode="before")
    @classmethod
    def normalize_optional_role(cls, value: Any) -> Optional[PapelUsuario]:
        return _parse_role(value, allow_none=True)


class UserRegister(BaseModel):
    """Schema para registro local de usuario"""

    nm_email: EmailStr = Field(..., description="Email do usuario")
    nm_completo: str = Field(..., description="Nome completo")
    senha: str = Field(..., description="Senha em texto claro")
    nm_papel: Optional[PapelUsuario] = Field(
        PapelUsuario.USUARIO, description="Papel do usuario"
    )

    @field_validator("nm_papel", mode="before")
    @classmethod
    def normalize_register_role(cls, value: Any) -> PapelUsuario:
        role = _parse_role(value, allow_none=False)
        assert role is not None
        return role


class UserLoginLocal(BaseModel):
    """Schema para login local por email e senha"""

    nm_email: EmailStr = Field(..., description="Email do usuario")
    senha: str = Field(..., description="Senha em texto claro")


